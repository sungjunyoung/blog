<!doctype html><html lang=en><head><title>Goroutine 은 어떻게 동작할까? ::
sungjunyoung</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="본 포스트는 GopherCon 2018 Kavya Joshi 의 The Scheduler Saga 발표를 재구성하여 작성하였습니다.
 Intro Golang 의 장점으로 빠짐없이 언급되는 것이 바로 강력한 동시성 지원입니다. 이 강력한 동시성에서 빠질 수 없는 요소가 바로 goroutine 입니다. 개발자는 go 키워드를 통해 goroutine 을 생성함으로서 손쉽게 동시성을 지원하는 프로그램을 개발할 수 있습니다. Channel 을 사용하면 goroutine 간에 데이터를 손쉽게 전달할 수 도 있죠.
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { go f() fmt."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://sungjunyoung.github.io/posts/how-goroutine-works/><link rel=stylesheet href=https://sungjunyoung.github.io/assets/style.css><link rel=stylesheet href=https://sungjunyoung.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://sungjunyoung.github.io/assets/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://sungjunyoung.github.io/assets/img/favicon.png><link href=https://sungjunyoung.github.io/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sungjunyoung.github.io/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sungjunyoung.github.io/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sungjunyoung.github.io/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sungjunyoung.github.io/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=https://sungjunyoung.github.io/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Goroutine 은 어떻게 동작할까?"><meta name=twitter:description content="본 포스트는 GopherCon 2018 Kavya Joshi 의 The Scheduler Saga 발표를 재구성하여 작성하였습니다.
 Intro Golang 의 장점으로 빠짐없이 언급되는 것이 바로 강력한 동시성 지원입니다. 이 강력한 동시성에서 빠질 수 없는 요소가 바로 goroutine 입니다. 개발자는 go 키워드를 통해 goroutine 을 생성함으로서 손쉽게 동시성을 지원하는 프로그램을 개발할 수 있습니다. Channel 을 사용하면 goroutine 간에 데이터를 손쉽게 전달할 수 도 있죠.
package main import ( &#34;fmt&#34; &#34;time&#34; ) func main() { go f() fmt."><meta property="og:title" content="Goroutine 은 어떻게 동작할까?"><meta property="og:description" content="본 포스트는 GopherCon 2018 Kavya Joshi 의 The Scheduler Saga 발표를 재구성하여 작성하였습니다.
 Intro Golang 의 장점으로 빠짐없이 언급되는 것이 바로 강력한 동시성 지원입니다. 이 강력한 동시성에서 빠질 수 없는 요소가 바로 goroutine 입니다. 개발자는 go 키워드를 통해 goroutine 을 생성함으로서 손쉽게 동시성을 지원하는 프로그램을 개발할 수 있습니다. Channel 을 사용하면 goroutine 간에 데이터를 손쉽게 전달할 수 도 있죠.
package main import ( &#34;fmt&#34; &#34;time&#34; ) func main() { go f() fmt."><meta property="og:type" content="article"><meta property="og:url" content="https://sungjunyoung.github.io/posts/how-goroutine-works/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-05-17T00:45:48+09:00"><meta property="article:modified_time" content="2021-05-17T00:45:48+09:00"><meta property="og:site_name" content="sungjunyoung"><script async src="https://www.googletagmanager.com/gtag/js?id=G-CMFR9WZ898"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-CMFR9WZ898',{anonymize_ip:!1})}</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-CMFR9WZ898','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>sungjunyoung</span>
<span class=logo__cursor></span></a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Goroutine 은 어떻게 동작할까?</h1><div class=post-meta><span class=post-date>2021-05-17</span></div><span class=post-tags><a href=https://sungjunyoung.github.io/tags/golang/>#golang</a>&nbsp;</span><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#goroutine--kernel-thread>Goroutine != (Kernel) Thread</a></li><li><a href=#go-runtime-scheduler>Go Runtime Scheduler</a></li><li><a href=#runqueue>runqueue</a></li><li><a href=#scheduler-idea>Scheduler Idea</a><ul><li><a href=#idea-i-reuse-threads>idea I: Reuse threads</a></li><li><a href=#idea-ii-limit-threads-accessing-runqueue>idea II: Limit threads accessing runqueue</a></li><li><a href=#idea-iii-distributed-runqueues>idea III: Distributed runqueues</a></li></ul></li><li><a href=#blocking-system-call>Blocking System call</a><ul><li><a href=#hand-off>Hand off</a></li></ul></li><li><a href=#정리>정리</a></li></ul></nav></aside><blockquote><p>본 포스트는 GopherCon 2018 <a href=https://www.linkedin.com/in/kavyajoshi/>Kavya Joshi</a> 의 <a href=https://youtu.be/YHRO5WQGh0k>The Scheduler Saga</a> 발표를 재구성하여 작성하였습니다.</p></blockquote><h2 id=intro>Intro</h2><p>Golang 의 장점으로 빠짐없이 언급되는 것이 바로 강력한 동시성 지원입니다.
이 강력한 동시성에서 빠질 수 없는 요소가 바로 <code>goroutine</code> 입니다.
개발자는 <code>go</code> 키워드를 통해 <code>goroutine</code> 을 생성함으로서 손쉽게 동시성을 지원하는 프로그램을 개발할 수 있습니다.
Channel 을 사용하면 <code>goroutine</code> 간에 데이터를 손쉽게 전달할 수 도 있죠.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;fmt&#34;</span>
    <span style=color:#e6db74>&#34;time&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>f</span>()

    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;hello world&#34;</span>)
    <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>f</span>() {
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;count: %d\n&#34;</span>, <span style=color:#a6e22e>i</span>)
        <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    }
}
<span style=color:#75715e>// hello world
</span><span style=color:#75715e>// count: 0
</span><span style=color:#75715e>// count: 1
</span><span style=color:#75715e>// count: 2
</span><span style=color:#75715e>// count: 3
</span><span style=color:#75715e>// count: 4
</span></code></pre></div><p>얼핏 보면 <code>goroutine</code> 은 다른 프로그래밍 언어에서 사용되는 Thread 와 같다고 생각할 수 있습니다.
하지만, <a href=https://tour.golang.org/concurrency/1>A Tour of Go</a> 에서는 <code>goroutine</code> 을 아래와 같이 정의하고 있습니다.</p><blockquote><p>&ldquo;lightweight thread managed by the Go runtime&rdquo;</p></blockquote><p>직역해보면 Go runtime 에 의해 관리되는 경량화된 스레드인데, 왠지 Thread 와는 다른 듯한 뉘앙스를 풍깁니다.
<code>goroutine</code> 은 무엇이고, 어떻게 동작하는지 한번 알아보겠습니다.</p><h2 id=goroutine--kernel-thread>Goroutine != (Kernel) Thread</h2><p><code>goroutine</code> 은 커널 스레드 와는 다른 리소스입니다.
위에서 <code>lightweight thread</code> 라고 정의 내렸던 만큼, <code>goroutine</code> 은 스레드보다 경량화된 동시성을 위한 리소스 입니다.
스케줄러에 의해 관리되고, 개별 스택을 가지며 프로세스와 힙 영역을 공유하는 등 많은 부분에서 스레드와 비슷하게 동작하지만,
스레드와 동작 방식이 다른 부분이 존재하며 더 가볍게 동작하게 됩니다.</p><p>먼저, <code>goroutine</code> 의 기본 스택 영역은 2KB 정도로, 스레드 기본 스택 영역인 8KB (32-bit 기준) 보다 작습니다.
또한, 생성 / 삭제 및 Context switch 시 스레드는 수 μs 정도 걸리는 반면 <code>goroutine</code> 은 수십 ns 만에 완료됩니다.
스레드 생성 및 삭제에는 System Call 이 수행되어야 하지만, <code>goroutine</code> 은 System Call 없이 유저 스페이스에서 동작을 완료할 수 있기 때문입니다.</p><figure class=left><img src=/assets/posts/how-goroutine-works/goroutine-external-structure.png><figcaption class=center>[그림-1] 커널 스레드 위에서 실행되는 Goroutine</figcaption></figure><p>이렇게 가벼운 <code>goroutine</code> 은 스레드 위에서 스케줄링되어 동작하게 됩니다.</p><figure class=left><img src=/assets/posts/how-goroutine-works/goroutine-binding.png><figcaption class=center>[그림-2] Goroutine 의 실행구조</figcaption></figure><p>또한 위와 같이 하나의 OS 커널 스레드 에 바인딩된 논리적 프로세서에서 실행되며,
<code>goroutine</code> 이 실행 가능한 상태가 되면 실행 큐에 추가되어 실행되게 되죠.</p><p>한가지 의문점이 있습니다. 커널 스레드의 경우 OS 스케줄러에 의해 관리된다고 했습니다.
그렇다면 <code>goroutine</code> 은 누가 관리해 줄까요?</p><h2 id=go-runtime-scheduler>Go Runtime Scheduler</h2><p>goroutine 은 <code>Runtime Scheduler</code> 에 의해 관리됩니다.
<code>Runtime Scheduler</code> 는 Go 프로그램이 실행되는 시점에 함께 실행되며,
goroutine 을 효율적으로 스레드에 스케줄링 시키는 역할을 수행합니다.</p><p>아래와 같은 원칙을 가지고 goroutine 을 적절하게 스케줄링 시키게 됩니다.</p><ul><li>커널 스레드는 비싸기 때문에 되도록 작은 수를 사용한다.</li><li>많은 수의 goroutine 을 실행하여 높은 <code>Concurrency</code> 를 유지한다.</li><li>N 코어 머신에서, N 개의 goroutine 을 <code>Parallel</code> 하게 동작시킨다.</li></ul><p>내부적으로 어떤 방식을 통하여 goroutine 을 스케줄링 시키는지 알아보겠습니다.</p><h2 id=runqueue>runqueue</h2><p>먼저, <code>runqueue</code> 라는 리소스에 대해서 알아보겠습니다.</p><p>goroutine 작업들은 스레드 별로 Heap 영역에 할당된 <code>runqueue</code> 에 의해 추적됩니다.
이름에서 알 수 있듯이 <code>runqueue</code> 는 FIFO 형태의 큐 자료구조를 가지며, 실행 가능한 상태의 goroutine 들을 보관합니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>schedt</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#f92672>...</span>
	<span style=color:#75715e>// Global runnable queue.
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>runq</span>     <span style=color:#a6e22e>gQueue</span>
	<span style=color:#a6e22e>runqsize</span> <span style=color:#66d9ef>int32</span>
    <span style=color:#f92672>...</span>
}
<span style=color:#75715e>// https://github.com/golang/go/blob/3b304ce7fe35b9d1e8cf0b0518ed2550c361a010/src/runtime/runtime2.go#L777
</span></code></pre></div><p><code>[그림-2]</code> 에서 Processor 에 대기 중인 goroutine 들이 여기에 보관됩니다.</p><h2 id=scheduler-idea>Scheduler Idea</h2><p>그럼 이제 본격적으로 goroutine 을 스레드에 스케줄링 하는 아이디어들을 살펴봅시다.</p><h3 id=idea-i-reuse-threads>idea I: Reuse threads</h3><blockquote><p>Create threads when needed; Keep them around for reuse</p></blockquote><p>Runtime Scheduler 는 goroutine 이 필요할 때 스레드를 생성합니다.
스레드에 더이상 실행할 goroutine 이 없다면 어떻게 하는게 좋을까요?
아시다시피, 스레드를 종료할 때도 System Call (<code>pthread_exit</code>) 이 필요하며,
자원 반납 과정에서의 로드가 존재합니다.
또한 다시 스레드를 생성할 때에도 같은 부하가 발생합니다.
Runtime Scheduler 는 이 과정을 생략하고, 스레드를 <code>idle</code> 상태로 둡니다.
스레드가 <code>idle</code> 상태가 되면, CPU 코어를 사용하지 않고 대기할 수 있습니다.
이렇게 idle 상태가 된 스레드 리스트는 별도로 보관하게 됩니다.</p><p>이렇게 스레드를 재활용하는 아이디어로, 스레드 생성/삭제에 대한 부하 없이 고루틴을 스레드에 빠르게 스케줄링 할 수 있습니다.</p><p>goroutine g1 이 실행되고, 종료 후 g2 가 실행되는 과정</p><ol><li><code>g1</code> 이 생성되고, local runqueue 에 추가됨</li><li>메인 스레드를 포함하여 모든 스레드가 busy 이므로, 새로운 스레드(<code>T1</code>) 를 생성하고 <code>g1</code> 을 <code>T1</code> 에 스케줄링</li><li><code>g1</code> 의 작업이 끝나고 <code>T1</code> 스레드는 종료되지 않고 idle 상태로 보관됨</li><li>새로운 goroutine <code>g2</code> 가 생성되고, idle 상태의 스레드 <code>T1</code> 을 재활용하여 실행</li></ol><figure class=left><img src=/assets/posts/how-goroutine-works/reuse-thread.gif><figcaption class=center>[그림-3] 커널 스레드 재활용</figcaption></figure><p>스레드를 재사용하는 것은 정말 좋은 아이디어 같습니다. 하지만, 여기서도 문제가 있습니다.
만약 현재 상태에서 goroutine 이 끊임없이 생성되면 어떻게 될까요?
모든 스레드가 계속 busy 상태이기 때문에, 스레드는 계속해서 생성되고,
이렇게 되면 idle 상태의 스레드가 엄청나게 쌓일 수 있습니다.
이 문제는 어떻게 해결하면 좋을까요?</p><h3 id=idea-ii-limit-threads-accessing-runqueue>idea II: Limit threads accessing runqueue</h3><p>간단하게, 생성할 수 있는 스레드 수를 제한함으로서 해결이 가능합니다.
<code>특정 조건</code>으로 스레드 수를 제한하면, 더이상 스레드가 생성되지 않게 할 수 있고,
실행 가능한 goroutine 을 대기시킴으로서 적절하게 프로세싱 파워를 사용할 수 있습니다.</p><p>이 <code>특정 조건</code>은 어떻게 결정하는게 좋을까요?
Go 에서는 이 조건을 CPU 코어의 갯수로 제한합니다.
생성되는 스레드를 CPU 코어 갯수만큼만 생성하도록 하는 것이죠.
이렇게 모든 CPU 코어가 스레드를 실행하게 함으로서 적정 수준의 Parallelism 을 달성할 수 있게 됩니다.</p><p>이 갯수는 디폴트 값으로 CPU 코어 갯수로 지정되지만,
<code>rumtime.GOMAXPROCS</code> 로 설정이 가능합니다.
이 설정은 하나의 노드에서 여러 Go 프로그램을 실행시킬 때 좀 더 좋은 성능을 위해 조절하기도 합니다.</p><figure class=left><img src=/assets/posts/how-goroutine-works/limit-thread.png><figcaption class=center>[그림-4] 커널 스레드 갯수 제한 (CPU 코어 = 2)</figcaption></figure><p>위 그림에서, CPU 코어가 2개인 상황에서 <code>g2</code> 가 실행되어야 하는 시점에,
모든 스레드가 busy 상태이면 CPU 코어 갯수 (2개) 이상으로 스레드를 생성하지 않고 대기합니다.
이후 메인 스레드에서 다른 goroutine 의 데이터를 받기 위해 <code>&lt;-ch</code> 로 블록되는 시점에 g2 가 메인 스레드에서 동작하게 됩니다.</p><p>또한 이 Limit 은 goroutine 을 실행하고 있는 스레드로 제한됩니다.
System Call 에서 사용되는 스레드는 이 조건에 포함되지 않습니다.
이 조건은 잠시 후 알아보도록 하겠습니다.</p><p>지금까지는 runqueue 가 글로벌하게 하나만 있다는 가정 하에 시뮬레이션을 진행했습니다.
하지만 단일 runqueue 환경에서는 goroutine 은 만족할만한 성능을 내지 못합니다.
runqueue 는 Heap 영역에 있는 공동의 리소스이고,
여기에 접근하여 enqueue, dequeue 작업을 하기 위해서는 goroutine 이 생성될 때마다 Lock 이 필요하기 때문입니다.</p><p>그래서 Go 에서는 스레드 별로 <code>local runqueue</code> 를 사용합니다.</p><h3 id=idea-iii-distributed-runqueues>idea III: Distributed runqueues</h3><blockquote><p>Use N runqueues on an N-core machine</p></blockquote><p>스레드는 각각 <code>local runqueue</code> 를 가집니다.
스레드는 local runqueue 에 실행할 goroutine 을 가지고,
이 goroutine 들을 가져와 실행하게 됩니다.</p><p>그럼 위에서 살펴보았던 과정을 local runqueue 를 추가하여 다시 한번 시뮬레이션 해봅시다.</p><ol><li>g1 goroutine 이 생성되어 runq A 에 추가됨</li><li>모두 busy 스레드이기 때문에 새로운 스레드 T1 생성</li><li>T1 이 g1 을 실행하려 하지만, runq B 에는 goroutine 이 없는 상태</li></ol><figure class=left><img src=/assets/posts/how-goroutine-works/local-runqueue-1.gif><figcaption class=center>[그림-5] 스레드별 local runqueue 상황에서의 스케줄링</figcaption></figure><p>보시다시피, runq B 에는 할당된 goroutine 이 없기 때문에 실행시킬 goroutine 이 없습니다.
어떻게 해야 할까요?</p><p>이런 상황에서, Runtime Scheduler 는 다른 local runqueue 의 goroutine 작업들을 <code>훔칩</code>니다.
자신의 runqueue 가 비어있는 경우, 다른 local runqueue 를 랜덤하게 선택한 후, goroutine 작업의 <code>절반</code>을 훔쳐옵니다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// stealWork attempts to steal a runnable goroutine or timer from any P.
</span><span style=color:#75715e>//
</span><span style=color:#75715e>// If newWork is true, new work may have been readied.
</span><span style=color:#75715e>//
</span><span style=color:#75715e>// If now is not 0 it is the current time. stealWork returns the passed time or
</span><span style=color:#75715e>// the current time if now was passed as 0.
</span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stealWork</span>(<span style=color:#a6e22e>now</span> <span style=color:#66d9ef>int64</span>) (<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>rnow</span>, <span style=color:#a6e22e>pollUntil</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>newWork</span> <span style=color:#66d9ef>bool</span>) {
    <span style=color:#f92672>...</span>
    				<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runqsteal</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>p2</span>, <span style=color:#a6e22e>stealTimersOrRunNextG</span>); <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
					<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>now</span>, <span style=color:#a6e22e>pollUntil</span>, <span style=color:#a6e22e>ranTimer</span>
				}
    <span style=color:#f92672>...</span>
}
<span style=color:#75715e>// https://github.com/golang/go/blob/03886707f9e8db668bd1fd7b8f99799dba0408e3/src/runtime/proc.go#L3013
</span></code></pre></div><p>위 코드에서 work stealing 을 확인할 수 있습니다.</p><figure class=left><img src=/assets/posts/how-goroutine-works/local-runqueue-2.gif><figcaption class=center>[그림-6] Work Stealing</figcaption></figure><p><code>[그림-5]</code> 의 과정을 다시 살펴보면, 위와 같이 다른 runqueue 의 작업을 훔쳐와 T1 스레드에서 동작시키는 것을 볼 수 있습니다.
이렇게 다른 runqueue 의 작업의 절반을 가져옴으로서 전체적으로 작업도 골고루 분배될 수 있습니다.</p><h2 id=blocking-system-call>Blocking System call</h2><p>다음과 같이 goroutine 을 사용한다고 가정해 봅시다.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>process</span>(<span style=color:#a6e22e>image</span>) { <span style=color:#75715e>// g1
</span><span style=color:#75715e></span>    <span style=color:#75715e>// goroutine 생성 
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>reportMetrics</span>() <span style=color:#75715e>// g3
</span><span style=color:#75715e></span>
    <span style=color:#a6e22e>complicatedAlgorithm</span>(<span style=color:#a6e22e>image</span>)
    
    <span style=color:#75715e>// 파일 Write
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>() <span style=color:#75715e>// goroutine &amp; thread block
</span><span style=color:#75715e></span>    <span style=color:#f92672>...</span>
}
</code></pre></div><p><code>g1</code> 이 <code>g3</code> 를 생성하고, I/O 작업 (Blocking system call) 을 수행합니다.
지금까지 내용을 바탕으로 유추해 보면, CPU 코어 갯수가 2개인 환경에서,
위와 같은 상황에서는 <code>main</code> goroutine 와 <code>g1</code> goroutine 이
각각 스레드를 사용하고 있으므로, <code>g3</code> 는 아직 실행되지 못하고 대기할 것입니다.
그리고 <code>g1</code> 은 <code>os.OpenFile()</code> 함수를 사용해 I/O 작업을 수행합니다.
Blocking system call 을 수행하게 되면, 응답이 올때까지 스레드는 Blocking 됩니다.
따라서 <code>g3</code> goroutine 은 system call 이 완료될 때까지 대기하게 되죠.</p><p>이런 상황에서 Runtime Scheduler 는 어떻게 이 문제를 해결할까요?</p><h3 id=hand-off>Hand off</h3><p>Runtime Scheduler 는 Background 모니터 스레드를 통해 일정 시간 블로킹 된 스레드를 감지합니다.
블로킹 스레드가 감지되고, idle 스레드가 없으면, 모니터는 스레드를 새로 만듭니다.</p><blockquote><p>위에서 스레드 Limit 은 goroutine 을 실행하고 있는 스레드로 제한된다고 하였지만,
System call 에서 사용되는 스레드는 이 조건에 포함되지 않는다고 하였습니다.
때문에 Blocking system call 을 수행하는 스레드는 이 Limit 에 포함되지 않습니다.</p></blockquote><p>이렇게 새로 만들어진 스레드의 runqueue 에, 기존에 쌓여있던 goroutine 작업들을 <code>handoff</code> 해줍니다.</p><figure class=left><img src=/assets/posts/how-goroutine-works/runqueue-handoff.png><figcaption class=center>[그림-7] Runqueue Handoff</figcaption></figure><p><code>handoff</code> 를 통해서 goroutine 의 starvation 을 방지할 수 있습니다.</p><h2 id=정리>정리</h2><p>Go 의 Runtime Scheduler 는 여러 아이디어를 바탕으로 경량화된 스레드를 최적화하여 스케줄링 할 수 있는 방법들을 고안해 내었습니다.</p><ul><li>스레드의 재사용</li><li>Goroutine 이 동작하는 스레드 갯수의 제한 (GOMAXPROCS)</li><li>분산된 runqueue</li><li>work stealing, handoff</li></ul><p>runqueue 가 Linux 스케줄러처럼 priority 를 제공하지 못하는 문제, 실제 system topology 를 반영하지 못하는 문제 등
아직 해결해야할 문제들이 많습니다.
하지만 goroutine 과 runtime scheduler 에 구현된 개념들이 강력한 아이디어인 것은 틀림없는 것 같습니다.</p><p><code>Kavya Joshi</code> 의 발표는 정말 쉽고 재밌게, 그리고 꼬리에 꼬리를 무는 문제점들과 그 해결법을 바탕으로 진행되어 흥미진진하게 들을 수 있어
공부하는데 도움이 많이 되는것 같습니다. 다른 발표들도 흥미로우니 한번쯤 들어보면 좋을것 같습니다.</p><ul><li><a href="https://www.youtube.com/watch?v=KBZlN0izeiY&t=11s">Understanding Channels</a></li><li><a href="https://www.youtube.com/watch?v=tjpncm3xTTc">Let&rsquo;s talk locks!</a></li></ul><p>이 포스트에서 언급된 내용 이외에도,</p><ul><li>sysmon 의 long running goroutine 감지 및 unschedule</li><li>global runqueue</li></ul><p>에 대한 내용이 <a href=https://youtu.be/YHRO5WQGh0k>발표</a> 뒷부분에 있습니다.</p><hr><p>Go 의 장점에서 왜 항상 강력한 동시성이 빠짐없이 등장하는지 아주 깊지는 않지만 조금은 이해가 되는 발표였습니다.</p></div><br><script>function updateUtterancTheme(){const a=window.localStorage&&window.localStorage.getItem("theme"),b={type:'set-theme',theme:a==="dark"?"photon-dark":"github-light"};var c=document.querySelector('iframe');c.contentWindow.postMessage(b,'https://utteranc.es')}window.addEventListener("storage",updateUtterancTheme),window.addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;updateUtterancTheme()})</script><script src=https://utteranc.es/client.js repo=sungjunyoung/sungjunyoung.github.io issue-term=pathname label=💬 theme=photon-dark crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>sungjunyoung</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2022 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=https://sungjunyoung.github.io/assets/main.js></script><script src=https://sungjunyoung.github.io/assets/prism.js></script></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-CMFR9WZ898"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-CMFR9WZ898',{anonymize_ip:!1})}</script></body></html>